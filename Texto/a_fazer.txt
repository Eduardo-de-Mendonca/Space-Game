A primeira prioridade, pra mim (Dudu), é decidir a questão do zoom que citei ali embaixo
    E depois dar a organizada no input

Incrementar a tela do espaço
    Com uma imagem de nave no lugar do quadradinho vermelho...
    Presumo que João esteja interessado em fazer isso

Fazer o básico da interação quando você está na superfície do planeta
    Isso envolve tomar algumas decisões sobre o esquema de controles
        Recorte de minha (Dudu) ideia sobre o esquema de controles
        "WASD para andar

        Clica para interagir (por exemplo, clicar em uma bancada de crafting para abrir o menu de crafting, clicar na nave para decolar...)

        Apertar um outro botão (como espaço ou clique com o botão direito, ou qualquer um dos dois) para usar o que você tem na mão
            Se for uma espada, isso ataca
            Se for um recurso como terra ou madeira, isso constrói
            Se for uma ferramenta como pá ou machado, isso usa a ferramenta para bater onde você clicou (ou então na frente do personagem)"

    Colocar um objeto no mapa da superfície representando sua espaçonave, de forma que seja possível clicar nela e voltar para o espaço
        E polir a lógica de colisão do espaço de forma que você não volte instantaneamente para o planeta devido à colisão

    Depois disso, é claro, vêm coisas mais complicadas, como inventário, inimigos e combate

Coisas a polir:
    Organizar melhor o input
        O input é lido por diferentes objetos em diferentes lugares. E ainda tem o handle_zoom da câmera, que é chamado direto lá do Game e lê o input.

        Isso é muito confuso e passível de erros. É bom ter uma classe Input que guarda todo o input para um frame, e um método que lê, o qual pode ser chamado uma vez no início de cada frame pelas telas. E aí encapsulamos para dentro dessa classe a lógica de ler o mouse scroll a partir dos eventos

    Pensar sobre zoom (continuação do problema de cima):
        zoom está adicionando algumas complicações para o projeto
            A questão de ter que ler o input de mouse scroll nos events, que mencionei em cima

            Ter que fazer contas com o zoom na hora de desenhar é chato. Não tem problema se encapsularmos toda essa lógica dentro da câmera. Mas o método draw de PlanetInSpace mostra algo um pouco difícil de encapsular (desenhando um círculo, em vez de desenhar uma imagem)
            Existem soluções, como escrever um método circle na câmera, ou transformar tudo (incluindo formas geométricas como círculos) em imagens antes de desenhar. Mas já é uma complicação

        Não acho que zoom controlável será uma feature do jogo
            Só, talvez, dentro de um minimapa ou algo do tipo

        Por isso, eu (Dudu) proponho remover o zoom. Para podermos ajustar o tamanho das coisas na tela, basta colocar, em settings, variáveis SCALE (ou outro nome parecido), e definir lá mesmo o tamanho das coisas multiplicado pelo scale. Ou seja, alteramos diretamente o tamanho das coisas, em vez de ter uma lógica de zoom por cima. E aí, isso só pode ser alterado de uma execução para outra do programa (não é dinâmico).

        Possivelmente também está no zoom a raiz do problema das retas pretas no planeta (que menciono abaixo)

        Do jeito que está, quando adicionei a tela do espaço, o zoom parou de funcionar na superfície do planeta. É claro! handle_zoom é chamado na câmera do espaço, e não na câmera da superfície. Isso é uma consequência da forma complicada em que o input de zoom é lido atualmente

    Geração de mapa:
        Imagino que Carlos vá ajustar estas coisas...
        O mapa é uma coluna verde seguida de um monte de água
        Além disso, quando você dá zoom, enquanto a câmera se mexe, aparecem várias retas pretas horizontais e verticais em diferentes posições

    Fazer a câmera já começar na posição do personagem, em vez de começar no meio do nada e fazer um movimento rapidão
        Só adicionar uns parâmetros de posição no init. Bem tranquilo